<!DOCTYPE html>
<html lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <title>FIRE-UI</title>
  <!-- <title>CodePen - On-Scroll Fire Transition (WebGL + GSAP ScrollTrigger)</title> -->
  
  <style>
    body, html {
    margin: 0;
    padding: 0;
    font-family: sans-serif;
    font-size: 20px;
    color: #3d3d3d;
}

a {
    color: inherit;
}

.page {
    width: 100%;
    min-height: 180vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    opacity: 0;
}

.page .header {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 40px;
    text-transform: uppercase;
    width: 100vw;
    margin-top: 20vh;
    height: 25vh;
}

.page .content {
    max-width: 800px;
    padding: 10px;
}

.page .last-line {
    text-align: right;
    padding-top: 1em;
}

.page ::-moz-selection {
    background: #F7C02D;
}

.page ::selection {
    background: #F7C02D;
}


<div class="page">
    <div class="header">
        PETS
    </div>
    <div class="content">
        <p>
            The HTML content you're reading right now is overlaid with a full-screen <b>&lt;canvas&gt;</b> element.
            There is a fragment shader that defines opacity and color for each pixel of the <b>&lt;canvas&gt;</b>.
            Shader input values are <b>animation progress</b>, <b>time</b>, and <b>resolution</b>.
        </p>
        <p>
            While <b>time</b> and <b>window size (resolution)</b> are super easy to gather, for <b>animation progress</b> I use <a href="https://gsap.com/docs/v3/Plugins/ScrollTrigger/" target="_blank">GSAP ScrollTrigger</a> plugin.
        </p>
        <p>
            Once the inputs are prepared, we pass them as uniforms to the shader.
            The WebGL part of this demo is a basic JS boilerplate to render a fragment shader on the single full-screen plane. No extra libraries here.
        </p>
        <p>
            The fragment shader is based on <a href="https://thebookofshaders.com/13/" target="_blank">Fractal Brownian Motion (fBm)</a> noise.
        </p>
        <p>
            First, we create a semi-transparent mask to define a contour of burning paper. It is basically a low-scale fBm noise with <b>animation progress</b> value used as a threshold.
            Taking the same fBm noise with different thresholds we can
            <br>
            (a) darken parts of the paper so each pixel gets darker before turning transparent
            <br>
            (b) define the stripe along the paper edge for fire.
        </p>
        <p>
            The fire is done as another two fBm based functions, one for shape and one for color. Both have a higher scale and both are animated with <b>time</b> value instead of <b>animation progress</b>.
        </p>

        <p class="last-line">
            <a href="https://www.linkedin.com/in/ksenia-kondrashova/" target="_blank">linkedIn</a> | <a href="https://codepen.io/ksenia-k" target="_blank">codepen</a> | <a href="https://twitter.com/uuuuuulala" target="_blank">twitter (X)</a>
        </p>
    </div>
</div>
